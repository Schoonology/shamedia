{
  "name": "stepdown",
  "version": "0.3.0",
  "description": "A simple control-flow library for Node that makes parallel execution, serial execution, and error handling painless.",
  "homepage": "http://github.com/Schoonology/stepdown",
  "repository": {
    "type": "git",
    "url": "git://github.com/Schoonology/stepdown.git"
  },
  "author": {
    "name": "Michael Schoonmaker",
    "email": "michael.r.schoonmaker@gmail.com"
  },
  "main": "lib/stepdown",
  "engines": {
    "node": ">=0.2.0"
  },
  "dependencies": {
    "trycatch": "~0.1.0",
    "survey": "~0.2.2"
  },
  "devDependencies": {
    "mocha": "",
    "chai": ""
  },
  "keywords": [
    "error",
    "exception",
    "control",
    "flow",
    "async",
    "series"
  ],
  "directories": {
    "example": "examples",
    "test": "test"
  },
  "scripts": {
    "test": "mocha --reporter spec",
    "bench": "survey ./bench/stepdown"
  },
  "license": "MIT",
  "optionalDependencies": {
    "survey": "~0.2.2"
  },
  "readme": "# Stepdown\n\nA simple control-flow library for node.JS that makes parallel execution, serial execution, and error handling painless.\n\n## How to install\n\n    npm install stepdown\n\n## Basic Usage (Serial)\n\nStepdown exports a single function:\n\n    stepdown(steps, [options], [callback])\n\nEach of the functions in the `steps` Array is called serially until that step has completed:\n\n    var stepdown = require('stepdown');\n\n    stepdown([function stepOne() {\n        return 'Step one is complete!';\n    }, function stepTwo(err, message) {\n        console.log(message);\n\n        this.next(null, 'Step two is complete!');\n    }, function finalStep(err, message) {\n        console.log(message);\n    }]);\n\nThe two basic methods of indicating that a step function has completed are by return value (as in `stepOne`) and by a callback function accessible as `this.next` (as in `stepTwo`). If you run this snippet, the output is what you expect:\n\n    Step one is complete!\n    Step two is complete!\n\nShiny!\n\n### Next _Steps_\n\nGoing beyond the [basic usage](#basic-usage-serial), Stepdown supports parallel execution in two ways: as a pre-defined set of \"[results](#adding-results-pre-defined-parallel)\", and as an arbitrary \"[group](#grouping-results-arbitrary-parallel)\" of results.\n\n## Adding Results (Pre-defined Parallel)\n\nThe [basic usage](#basic-usage-serial) and it's `next` callback assume that each step has exactly one (a)synchronous result, and that each step performs only one task. The beauty of Node is in its asynchronicity, and we should take advantage of that asynchronicity to perform as much of our work as we can in parallel.\n\nTo that end, enter `addResult`. Within a step, each call to `this.addResult()` generates a new callback function. Each of these functions corresponds to a new argument passed to the next step.\n\nInstead of this:\n\n    stepdown([function stepOne() {\n        // Do something asynchronous\n        setTimeout(this.next.bind(this, null, 1), 1000);\n    }, function stepTwo(err, result) {\n        // Do something else asynchronous with no dependency on the first step\n        setTimeout(this.next.bind(this, null, result, 2), 1000);\n    }, function finished(err, first, second) {\n        // This process would get really messy and take a really long time with lots of steps...\n        console.log('Results:', first, second);\n    }]);\n\nWe can do this:\n\n    stepdown([function onlyStep() {\n        // Do something asynchronous\n        setTimeout(this.addResult().bind(this, null, 1), 1000);\n        // Do something else asynchronous with no dependency on the first step\n        setTimeout(this.addResult().bind(this, null, 2), 1000);\n    }, function finished(err, first, second) {\n        // This is both more maintainable and more time-efficient.\n        console.log('Results:', first, second);\n    }]);\n\nMuch better, no?\n\n### Important Caveat\n\nThe caveat to `addResult` is that these callback functions are allocated synchronously, requiring the developer to explicitly prescribe what results are expected ahead of time. To get around this, we can create [arbitrary groups of results](#grouping-results-arbitrary-parallel).\n\n## Grouping Results (Arbitrary Parallel)\n\nWhile `addResult` is sufficent and recommended for parallel operations known ahead-of-time, it's impractical-to-incapable of handling arbitrary sets of parallel operations. Enter `createGroup`. Within a step, each call to `this.createGroup()` generates a new \"group\" function. When this group function is called, it generates a new callback specific to that result _within the group_.\n\nThe same example from before, but grouped:\n\n    stepdown([function onlyStep() {\n        var groupFn = this.createGroup();\n\n        // Do something asynchronous\n        setTimeout(groupFn().bind(this, null, 1), 1000);\n        // Do something else asynchronous with no dependency on the first step\n        setTimeout(groupFn().bind(this, null, 2), 1000);\n    }, function finished(err, group) {\n        console.log('Group Results:', group);\n    }]);\n\nUsing the group function should look incredibly similar to using `addResult`.\n\n## Moving from Step/Stepup\n\nComing (back) soon.\n\n## Attribution\n\nThis work stands on the shoulders of giants:\n\n * Tim Caswell [creationix](https://github.com/creationix), who created [Step](https://github.com/creationix/step).\n * Adam Crabtree [CrabDude](https://github.com/CrabDude), who created [Stepup](https://github.com/CrabDude/stepup).\n\n## Improvements\n\nStep and Stepup are great libraries, but Stepdown profits from their work in enabling the following improvements in the core engine:\n\n * If more than one Error is generated during parallel execution, the error handler will be called with an Array of all Errors. Step and Stepup only return the last Error.\n * If more than one result is generated during parallel execution, the value given to the next step will be an Array of all arguments passed. Step and Stepup only pass on the first non-Error argument.\n * If a parallel callback is fired more than once, it will be ignored. Step and Stepup break under these circumstances.\n",
  "_id": "stepdown@0.3.0",
  "_from": "stepdown"
}
